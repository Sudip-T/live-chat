https://medium.com/atomic-loops/django-channels-is-all-you-need-94628dd6815c
https://dev.to/sirneij/backend-one-on-one-duologue-chatting-application-with-django-channels-and-sveltekit-1bim
https://github.com/Omkar0231/Chat-app-tutorial/blob/master/chat/consumers.py


https://www.youtube.com/watch?v=205tbCUl4Uk&ab_channel=TheCodrammers
https://www.youtube.com/watch?v=YnrgBeIRtvo&ab_channel=Djangoroad
https://www.youtube.com/watch?v=RsrJzKPigc4&ab_channel=THEPROTONGUY

from django.contrib import admin
from .models import CustomUser


class CustomUserAdmin(admin.ModelAdmin):
    # exclude = ('password',)
    ordering = ('email',)
    list_display = ('email', 'first_name', 'last_name', 'is_superuser')
    search_fields = ('email', 'first_name', 'last_name')
    
admin.site.register(CustomUser, CustomUserAdmin)

from django.contrib.auth.base_user import BaseUserManager



class CustomUserManager(BaseUserManager):

    def create_user(self, email, password=None): 
        if not email:
            raise ValueError('Users must have an email address')

        user = self.model(
            email=self.normalize_email(email),
        )

        user.set_password(password)
        user.save(using=self._db)
        return user
        
    def create_superuser(self, email, password=None):
        user = self.create_user(
            email,
            password=password,
        )
        user.is_admin = True
        user.is_superuser = True
        user.is_staff = True
        user.save(using=self._db)
        return user

from django.db import models
from .manager import CustomUserManager
from django.contrib.auth.models import AbstractUser


class CustomUser(AbstractUser):
    username = None
    email = models.EmailField(unique=True)

    objects = CustomUserManager()

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = [] 



from rest_framework import serializers
from django.contrib.auth import get_user_model

User = get_user_model()


class UserRegisterSerializer(serializers.ModelSerializer):
    email = serializers.EmailField(required=True)
    password = serializers.CharField(min_length=8,max_length=16, write_only=True)
    confirm_password = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = ['email', 'password', 'confirm_password']

    def validate_email(self, value):
        if User.objects.filter(email=value).exists():
            raise serializers.ValidationError("A user with this email already exists.")
        return value

    def validate(self, attrs):
        print(attrs.get('passsword'))
        if attrs.get('password') != attrs.get('confirm_password'):
            raise serializers.ValidationError({
                'password': 'Password and Confirm Password do not match.'
            })
       
        return attrs
    
    def create(self, validated_data):
        password = validated_data.pop('password')
        validated_data.pop('confirm_password')
        user = User(**validated_data)
        user.set_password(password)
        user.save()
        return user


from django.urls import path
from .views import CustomAuthToken, Logout, UserRegistrationView

urlpatterns = [
    path('register/',UserRegistrationView.as_view(),name='register'),
    path('login/token/', CustomAuthToken.as_view(), name='token_auth'),
    path('logout/', Logout.as_view(), name='logout'),
]



from rest_framework.authtoken.models import Token
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework import status
from django.db import transaction


from rest_framework import generics
from . import serializers
from django.contrib.auth import get_user_model


User=get_user_model()


class UserRegistrationView(generics.CreateAPIView):
    serializer_class=serializers.UserRegisterSerializer

    def post(self, request):
        serializer = self.serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)
        with transaction.atomic():
            user = serializer.save()
            token = Token.objects.create(user=user)
        return Response(
            {'status':'success','token':token.key}, 
            status=status.HTTP_201_CREATED)
    

class CustomAuthToken(ObtainAuthToken):
    authentication_classes = []
    def post(self, request, *args, **kwargs):
        serializer = self.serializer_class(data=request.data,
                                           context={'request': request})
        serializer.is_valid(raise_exception=True)
        user = serializer.validated_data['user']
        token, created = Token.objects.get_or_create(user=user)
        return Response({'token': token.key})


class Logout(APIView):
    def post(self, request):
        request.user.auth_token.delete()
        return Response(status=status.HTTP_200_OK)


https://documenter.getpostman.com/view/28231090/2sA3XSC1my
